{"componentChunkName":"component---src-templates-post-template-js","path":"/posts/perfecting-the-art-of-perfection","result":{"data":{"markdownRemark":{"id":"c3330191-ac83-59b2-b733-4d5fc648a0a2","html":"<p>A heap is a binary tree holding a distinct relation between every parent and their nodes - a parentâ€™s value (or key) is always less than (min-heap) or greater than (max-heap) their children.</p>\n<p><img src=\"/media/heap.jpg\" alt=\"Stacked, Balanced, Perfection. www.Studio51Film.com\"></p>\n<h4 id=\"tldr\" style=\"position:relative;\"><a href=\"#tldr\" aria-label=\"tldr permalink\" class=\"anchor before\"><svg aria-hidden=\"true\" focusable=\"false\" height=\"16\" version=\"1.1\" viewBox=\"0 0 16 16\" width=\"16\"><path fill-rule=\"evenodd\" d=\"M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z\"></path></svg></a>TLDR</h4>\n<p>Hereâ€™s a quick take-away if you donâ€™t want to read the whole thing.</p>\n<blockquote>\n<p>A (min)heap data-structure (a.k.a Priority queue) is model as a binary tree where each parent nodeâ€™s value (or key) is always less than (or equal to) their children.</p>\n</blockquote>\n<blockquote>\n<p>Theyâ€™re conveniently implemented using an array.</p>\n</blockquote>\n<blockquote>\n<p>For a parent node at index â€˜nâ€™, youâ€™ll find their children at <strong>2(n + 1)</strong> and <strong>2(n + 2)</strong> indices.</p>\n</blockquote>\n<blockquote>\n<p>For a node at index â€˜nâ€™, youâ€™ll find its parent at index <strong>Floor(n - 1)/2</strong></p>\n</blockquote>\n<blockquote>\n<p>For adding an element, we add at the end of the array and <em>bubble- up</em> the array(beginning).</p>\n</blockquote>\n<blockquote>\n<p>For deletion, we replace the first element with the last element and <em>bubble-down</em> the array(end).</p>\n</blockquote>\n<hr>\n<p>We shall be explaining on â€œmin-heapâ€ though the same concept can be equivalently applied to â€œmax-heapâ€ as well.</p>\n<p>The term â€œheapâ€ doesnâ€™t reflect anything, at-least to me, on the nature of this tree (read - binary tree) and if you see the photo above, thatâ€™s the real-world concept of a heap - a random collection of things placed hapahzardly on top of each other. However, the structure that we are discussing here maintains a strict ordering between the items and therefore doesnâ€™t resemble this mental modal whatsoever shape or form.</p>\n<p>On top of this (difference between the real-concept and abstract-concept), almost all of the discussion on heap structure started right away explaining with Binary Tree structure and immediately implemented using the Array structure. <u>What is missing though is the explanation of why we model it as one structure (binary tree) but implemented with another structure (i.e. Array in this case)</u>. In order to understand this concern, we need to dive deeper and look again into the heap property and the algorithms to add and delete items from it.</p>\n<p>Before that, you may ask me - how do I map (or hook) the concept of heap into my mental model? The way I remember is that <u>heap is nothing but a fancy name of â€œPriority Queueâ€</u> - a queue of things where each thing carries a weight called â€œpriorityâ€ with it. In such queue, low priority element is served before an element with high priority (the reverse is true for max-heap)</p>\n<p>With that interpretation, letâ€™s jump into the analysis.</p>\n<ol>\n<li>Heap property - Every parent node (read as nodeâ€™s value) must be smaller  than or equal to its children (left &#x26; right child), In other words, every parent node must not be greater than its left and right sub-tree(s).</li>\n</ol>\n<p>How would we satisfy this property using Binary Tree in all operations, notably during addition and deletion of items?</p>\n<p>For binary search tree(BST), as the parent node is always between its left child and right child, insertion and deletion are easily done using a well-defined BST algorithms. </p>\n<p>For heap binary tree, letâ€™s start with a single node P. That is also a heap. No problem. Letâ€™s assume thereâ€™re new items M and N coming in, and imagine that theyâ€™re smaller than P. On what basis would you decide which one should be left and right child? You canâ€™t just decide randomly there. Again, if they are larger than P or if any one is larger than P, how would we decide the final arrangement without breaking the heap property. We canâ€™t arrange them randomly because it should work in all insertion and deletion operations.</p>\n<p>Nonetheless, thereâ€™re ways to implement this (<a href=\"https://stackoverflow.com/questions/18241192/implement-heap-using-a-binary-tree\" target=\"_blank\" rel=\"nofollow noopener noreferrer\">https://stackoverflow.com/questions/18241192/implement-heap-using-a-binary-tree</a>) arrangement using binary tree itself, but weâ€™ll not go into the details of them (perhaps another article to analyze theit complexity with that of Array implementation).</p>\n<p>We will be looking at how Array might sove this issue of arranging parents and their child nodes (rather beautifully yet intituitively) though maintaining the heap property.</p>\n<p>Before that, how do we map (or hook) into our mental model? The way I remember is that <u>heap is a fancy name of â€œPriority Queueâ€</u> - a queue of things where each thing carries a weight called â€œpriorityâ€ with it. In such queue, low priority element is served before an element with high priority (the reverse is true for max-heap)</p>\n<p>One key thing that you might already see in Array but not there in Tree is that - Array elements are uniquely ordered from 0, then 1, 2 and so onâ€¦And thatâ€™s not the case with Tree and therefore weâ€™ve different traversals of tree structure (Post Order, In order, Pre Order, Breadth-first, Depth-first etc). And most notably, an array index P, <u>is always less than any subsequent indices that come after it</u>. Sounds similar with the heap property?</p>\n<p>Letâ€™s draw  binary tree representation of a min-heap structure and weâ€™ll see how it can be mapped to Array easily.</p>\n<p><img src=\"/media/minheap.jpg\" alt=\"Heap Binary Tree\"></p>\n<p>The above binary tree can also be drawn as below. Why not? A tree could have wierd branches!ğŸ˜</p>\n<p><img src=\"/media/waterfall.jpg\" alt=\"A skewed heap binary tree\"></p>\n<p>And imagine, we map each element to an array as shown below -</p>\n<p><img src=\"/media/tree-array-map.jpg\" alt=\"Binary Tree to Array mapping\"></p>\n<p>Voila! we mapped the binary tree into an array representation. And interesting thing is that, any array element can be treated as a parent node and all its children (which is on its right side, not necessarily adjacent one) will always be greater than or equal to its value. We now satisfied the heap property.</p>\n<p>Also, for any array element (read as node in binary heap) at array index â€œnâ€, youâ€™ll find its children (left and right child) at 2(n + 1) and 2(n + 2) respectively.</p>\n<p>Finally, coming to the addition and deletion of items in Binary heap (refer TLDR above), the algorithm demands inserting element at the end or beginning of an array and that is a constant time, O(1) complexity in array, which is not so in a binary tree.</p>\n<p>This explains the reason why we describes Heap structure as a Binary Tree but implemented rather as an Array structure.</p>\n<p>I know this topic is in the longer side. We would also like to discuss the implementation and also two primary applications of heap data structure - 1) <strong>Merging K-Sorted arrays</strong> and 2) <strong>Djikstraâ€™s shortest path algorithm</strong></p>\n<p>We shall discuss these two in the next section. Stay tuned!</p>","fields":{"slug":"/posts/perfecting-the-art-of-perfection","tagSlugs":["/tag/data-structure/","/tag/binary-tree/","/tag/array/"]},"frontmatter":{"date":"2020-06-11T23:46:37.121Z","description":"A heap is a binary tree holding a distinct relation between every parent and their nodes - a parent's value (or key) is always less than (min-heap) or greater than (max-heap) their children ","tags":["Data Structure","Binary Tree","Array"],"title":"My mental model on Heap Structure","socialImage":"/media/heap.jpg"}}},"pageContext":{"slug":"/posts/perfecting-the-art-of-perfection"}}}